/**
 * Schema Comparator - Compares two database schemas and generates migration scripts
 */
class SchemaComparator {
    constructor(sourceSchema, destSchema, options = {}) {
        this.source = sourceSchema;
        this.dest = destSchema;
        this.migrationScript = [];
        this.options = {
            detectDrops: options.detectDrops || false,
            preserveColumnOrder: options.preserveColumnOrder || false,
            ...options
        };
        this.stats = {
            tablesAdded: 0,
            tablesDropped: 0,
            columnsAdded: 0,
            columnsModified: 0,
            columnsDropped: 0,
            indexesAdded: 0
        };
    }

    compare() {
        this.migrationScript.push("-- ----------------------------------------------------------------");
        this.migrationScript.push("-- Migration Script Generated by JS DDL Tool");
        this.migrationScript.push("-- Goal: Apply changes to Destination to match Source");
        this.migrationScript.push(`-- Generated: ${new Date().toLocaleString()}`);
        this.migrationScript.push("-- ----------------------------------------------------------------\n");

        // 1. Missing Tables (in source but not in dest)
        for (const table in this.source) {
            if (!this.dest[table]) {
                this.stats.tablesAdded++;
                this.migrationScript.push(`-- [MISSING TABLE] ${table}`);
                this.migrationScript.push(this.source[table].full_create_stmt);
                this.migrationScript.push(""); 
            } else {
                this._compareTables(table);
            }
        }

        // 2. Dropped Tables (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            for (const table in this.dest) {
                if (!this.source[table]) {
                    this.stats.tablesDropped++;
                    this.migrationScript.push(`-- [TABLE TO DROP] ${table}`);
                    this.migrationScript.push(`DROP TABLE IF EXISTS \`${table}\`;`);
                    this.migrationScript.push("");
                }
            }
        }

        if (this.migrationScript.length <= 5) {
            this.migrationScript.push("-- No schema differences found. Databases match!");
        }

        return this.migrationScript.join("\n");
    }

    _compareTables(tableName) {
        const srcTable = this.source[tableName];
        const dstTable = this.dest[tableName];
        const changes = [];

        // 2. Missing Columns or Type Mismatches
        for (const colName in srcTable.columns) {
            const srcColData = srcTable.columns[colName];
            
            if (!dstTable.columns[colName]) {
                // Missing Column
                this.stats.columnsAdded++;
                let addStmt = `ADD COLUMN \`${colName}\` ${srcColData.definition}`;
                
                // Add column position if preserveColumnOrder is enabled
                if (this.options.preserveColumnOrder && srcTable.columnOrder) {
                    const colIndex = srcTable.columnOrder.indexOf(colName);
                    if (colIndex > 0) {
                        const prevCol = srcTable.columnOrder[colIndex - 1];
                        addStmt += ` AFTER \`${prevCol}\``;
                    } else if (colIndex === 0 && srcTable.columnOrder.length > 1) {
                        addStmt += ` FIRST`;
                    }
                }
                
                changes.push(addStmt);
            } else {
                // Check Type and Default Value
                const dstColData = dstTable.columns[colName];
                const srcClean = this._normalizeType(srcColData.definition);
                const dstClean = this._normalizeType(dstColData.definition);

                // Compare default values
                const srcDefault = this._normalizeDefault(srcColData.default);
                const dstDefault = this._normalizeDefault(dstColData.default);

                if (srcClean !== dstClean || srcDefault !== dstDefault) {
                    this.stats.columnsModified++;
                    changes.push(`MODIFY COLUMN \`${colName}\` ${srcColData.definition}`);
                }
            }
        }

        // 3. Dropped Columns (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            for (const colName in dstTable.columns) {
                if (!srcTable.columns[colName]) {
                    this.stats.columnsDropped++;
                    changes.push(`DROP COLUMN \`${colName}\``);
                }
            }
        }

        // 4. Missing Indexes (including foreign keys)
        const srcIndexes = srcTable.indexes.map(idx => ({ raw: idx, norm: this._normalizeIndex(idx) }));
        const dstIndexesNorm = dstTable.indexes.map(idx => this._normalizeIndex(idx));

        for (const idxObj of srcIndexes) {
            if (!dstIndexesNorm.includes(idxObj.norm)) {
                this.stats.indexesAdded++;
                changes.push(`ADD ${idxObj.raw}`);
            }
        }

        // 5. Missing Foreign Keys (separate handling for better control)
        const srcForeignKeys = srcTable.foreignKeys || [];
        const dstForeignKeysNorm = (dstTable.foreignKeys || []).map(fk => this._normalizeIndex(fk));

        for (const fk of srcForeignKeys) {
            const fkNorm = this._normalizeIndex(fk);
            if (!dstForeignKeysNorm.includes(fkNorm)) {
                this.stats.indexesAdded++;
                changes.push(`ADD ${fk}`);
            }
        }

        if (changes.length > 0) {
            this.migrationScript.push(`-- Changes for table \`${tableName}\``);
            this.migrationScript.push(`ALTER TABLE \`${tableName}\``);
            // Indent and join with commas
            const indentedChanges = changes.map(c => "  " + c).join(",\n");
            this.migrationScript.push(indentedChanges + ";");
            this.migrationScript.push("");
        }
    }

    _normalizeType(typeStr) {
        return typeStr.toLowerCase().replace(/\s+/g, '').replace(/[`"']/g, '');
    }

    _normalizeIndex(indexStr) {
        return indexStr.toLowerCase().replace(/\s+/g, '').replace(/[`"']/g, '');
    }

    _normalizeDefault(defaultValue) {
        if (defaultValue === null || defaultValue === undefined) return null;
        return String(defaultValue).toLowerCase().replace(/[`"']/g, '').trim();
    }

    getStats() {
        return this.stats;
    }
}

// Export for Node.js/CommonJS environments
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SchemaComparator };
}

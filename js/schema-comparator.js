/**
 * Schema Comparator - Compares two database schemas and generates migration scripts
 */
class SchemaComparator {
    constructor(sourceSchema, destSchema, options = {}) {
        this.source = sourceSchema;
        this.dest = destSchema;
        this.migrationScript = [];
        this.options = {
            detectDrops: options.detectDrops || false,
            preserveColumnOrder: options.preserveColumnOrder || false,
            ...options
        };
        this.stats = {
            tablesAdded: 0,
            tablesDropped: 0,
            columnsAdded: 0,
            columnsModified: 0,
            columnsDropped: 0,
            indexesAdded: 0
        };
    }

    compare() {
        this.migrationScript.push('-- ----------------------------------------------------------------');
        this.migrationScript.push('-- Migration Script Generated by JS DDL Tool');
        this.migrationScript.push('-- Goal: Apply changes to Destination to match Source');
        this.migrationScript.push(`-- Generated: ${new Date().toLocaleString()}`);
        this.migrationScript.push('-- ----------------------------------------------------------------\n');

        // 1. Missing Tables (in source but not in dest)
        for (const table in this.source) {
            if (!this.dest[table]) {
                this.stats.tablesAdded++;
                this.migrationScript.push(`-- [MISSING TABLE] ${table}`);
                this.migrationScript.push(this.source[table].full_create_stmt);
                this.migrationScript.push('');
            } else {
                this._compareTables(table);
            }
        }

        // 2. Dropped Tables (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            for (const table in this.dest) {
                if (!this.source[table]) {
                    this.stats.tablesDropped++;
                    this.migrationScript.push(`-- [TABLE TO DROP] ${table}`);
                    this.migrationScript.push(`DROP TABLE IF EXISTS \`${table}\`;`);
                    this.migrationScript.push('');
                }
            }
        }

        if (this.migrationScript.length <= 5) {
            this.migrationScript.push('-- No schema differences found. Databases match!');
        }

        return this.migrationScript.join('\n');
    }

    _compareTables(tableName) {
        const srcTable = this.source[tableName];
        const dstTable = this.dest[tableName];
        const changes = [];

        // 2. Missing Columns or Type Mismatches
        for (const colName in srcTable.columns) {
            const srcColData = srcTable.columns[colName];

            if (!dstTable.columns[colName]) {
                // Missing Column
                this.stats.columnsAdded++;
                let addStmt = `ADD COLUMN \`${colName}\` ${srcColData.definition}`;

                // Add column position if preserveColumnOrder is enabled
                if (this.options.preserveColumnOrder && srcTable.columnOrder) {
                    const colIndex = srcTable.columnOrder.indexOf(colName);
                    if (colIndex > 0) {
                        const prevCol = srcTable.columnOrder[colIndex - 1];
                        addStmt += ` AFTER \`${prevCol}\``;
                    } else if (colIndex === 0 && srcTable.columnOrder.length > 1) {
                        addStmt += ' FIRST';
                    }
                }

                changes.push(addStmt);
            } else {
                // Check Type and Default Value
                const dstColData = dstTable.columns[colName];
                const srcClean = this._normalizeType(srcColData.definition);
                const dstClean = this._normalizeType(dstColData.definition);

                // Compare default values
                const srcDefault = this._normalizeDefault(srcColData.default);
                const dstDefault = this._normalizeDefault(dstColData.default);

                if (srcClean !== dstClean || srcDefault !== dstDefault) {
                    this.stats.columnsModified++;
                    changes.push(`MODIFY COLUMN \`${colName}\` ${srcColData.definition}`);
                }
            }
        }

        // 3. Dropped Columns (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            for (const colName in dstTable.columns) {
                if (!srcTable.columns[colName]) {
                    this.stats.columnsDropped++;
                    changes.push(`DROP COLUMN \`${colName}\``);
                }
            }
        }

        // 4. Handle PRIMARY KEY changes (must be done before other indexes)
        const srcPrimaryKey = this._extractPrimaryKey(srcTable.indexes);
        const dstPrimaryKey = this._extractPrimaryKey(dstTable.indexes);

        if (srcPrimaryKey && dstPrimaryKey) {
            // Both have PRIMARY KEY - check if they differ
            const srcPKNorm = this._normalizeIndex(srcPrimaryKey);
            const dstPKNorm = this._normalizeIndex(dstPrimaryKey);
            if (srcPKNorm !== dstPKNorm) {
                // PRIMARY KEY definition changed - must drop old one first
                changes.push('DROP PRIMARY KEY');
                changes.push(`ADD ${srcPrimaryKey}`);
            }
        } else if (srcPrimaryKey && !dstPrimaryKey) {
            // Source has PRIMARY KEY but destination doesn't
            changes.push(`ADD ${srcPrimaryKey}`);
        } else if (!srcPrimaryKey && dstPrimaryKey && this.options.detectDrops) {
            // Source doesn't have PRIMARY KEY but destination does - drop it if detectDrops enabled
            changes.push('DROP PRIMARY KEY');
        }

        // 5. Missing Indexes (excluding PRIMARY KEY which is handled above)
        const srcIndexes = srcTable.indexes
            .filter(idx => !this._isPrimaryKey(idx))
            .map(idx => ({ raw: idx, norm: this._normalizeIndex(idx) }));
        const dstIndexes = dstTable.indexes
            .filter(idx => !this._isPrimaryKey(idx))
            .map(idx => ({ raw: idx, norm: this._normalizeIndex(idx) }));
        const dstIndexesNorm = dstIndexes.map(idx => idx.norm);

        for (const idxObj of srcIndexes) {
            if (!dstIndexesNorm.includes(idxObj.norm)) {
                this.stats.indexesAdded++;
                changes.push(`ADD ${idxObj.raw}`);
            }
        }

        // 5b. Dropped Indexes (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            const srcIndexesNorm = srcIndexes.map(idx => idx.norm);
            for (const idxObj of dstIndexes) {
                if (!srcIndexesNorm.includes(idxObj.norm)) {
                    // Extract index name for DROP INDEX statement
                    const indexName = this._extractIndexName(idxObj.raw);
                    if (indexName) {
                        changes.push(`DROP INDEX \`${indexName}\``);
                    }
                }
            }
        }

        // 6. Missing Foreign Keys (separate handling for better control)
        const srcForeignKeys = srcTable.foreignKeys || [];
        const dstForeignKeys = (dstTable.foreignKeys || []).map(fk => ({ raw: fk, norm: this._normalizeIndex(fk) }));
        const dstForeignKeysNorm = dstForeignKeys.map(fk => fk.norm);

        for (const fk of srcForeignKeys) {
            const fkNorm = this._normalizeIndex(fk);
            if (!dstForeignKeysNorm.includes(fkNorm)) {
                this.stats.indexesAdded++;
                changes.push(`ADD ${fk}`);
            }
        }

        // 6b. Dropped Foreign Keys (in dest but not in source) - if enabled
        if (this.options.detectDrops) {
            const srcForeignKeysNorm = srcForeignKeys.map(fk => this._normalizeIndex(fk));
            for (const fkObj of dstForeignKeys) {
                if (!srcForeignKeysNorm.includes(fkObj.norm)) {
                    const fkName = this._extractForeignKeyName(fkObj.raw);
                    if (fkName) {
                        changes.push(`DROP FOREIGN KEY \`${fkName}\``);
                    }
                }
            }
        }

        if (changes.length > 0) {
            this.migrationScript.push(`-- Changes for table \`${tableName}\``);
            this.migrationScript.push(`ALTER TABLE \`${tableName}\``);
            // Indent and join with commas
            const indentedChanges = changes.map(c => '  ' + c).join(',\n');
            this.migrationScript.push(indentedChanges + ';');
            this.migrationScript.push('');
        }
    }

    _normalizeType(typeStr) {
        return typeStr.toLowerCase().replace(/\s+/g, '').replace(/[`"']/g, '');
    }

    _normalizeIndex(indexStr) {
        return indexStr.toLowerCase().replace(/\s+/g, '').replace(/[`"']/g, '');
    }

    _isPrimaryKey(indexStr) {
        return indexStr.toUpperCase().trim().startsWith('PRIMARY KEY');
    }

    _extractPrimaryKey(indexes) {
        for (const idx of indexes) {
            if (this._isPrimaryKey(idx)) {
                return idx;
            }
        }
        return null;
    }

    _extractIndexName(indexStr) {
        // Try to extract index name from various formats:
        // KEY `idx_name` (...)
        // INDEX `idx_name` (...)
        // UNIQUE KEY `idx_name` (...)
        // UNIQUE INDEX `idx_name` (...)
        const match = indexStr.match(/(?:UNIQUE\s+)?(?:KEY|INDEX)\s+[`"]?(\w+)[`"]?/i);
        return match ? match[1] : null;
    }

    _extractForeignKeyName(fkStr) {
        // Extract foreign key constraint name
        // FOREIGN KEY `fk_name` (...) or CONSTRAINT `fk_name` FOREIGN KEY (...)
        const match = fkStr.match(/(?:CONSTRAINT\s+[`"]?(\w+)[`"]?\s+)?FOREIGN\s+KEY/i);
        if (match && match[1]) {
            return match[1];
        }
        // Try to extract from FOREIGN KEY `fk_name` format
        const match2 = fkStr.match(/FOREIGN\s+KEY\s+[`"]?(\w+)[`"]?/i);
        return match2 ? match2[1] : null;
    }

    _normalizeDefault(defaultValue) {
        if (defaultValue === null || defaultValue === undefined) return null;
        return String(defaultValue).toLowerCase().replace(/[`"']/g, '').trim();
    }

    getStats() {
        return this.stats;
    }
}

// Export for Node.js/CommonJS environments
/* eslint-disable no-undef */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SchemaComparator };
}
